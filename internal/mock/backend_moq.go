// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/daichitakahashi/confort"
	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/network"
	"github.com/docker/go-connections/nat"
	"io"
	"sync"
)

// Ensure, that BackendMock does implement confort.Backend.
// If this is not the case, regenerate this file with moq.
var _ confort.Backend = &BackendMock{}

// BackendMock is a mock implementation of confort.Backend.
//
// 	func TestSomethingThatUsesBackend(t *testing.T) {
//
// 		// make and configure a mocked confort.Backend
// 		mockedBackend := &BackendMock{
// 			BuildImageFunc: func(ctx context.Context, buildContext io.Reader, buildOptions types.ImageBuildOptions, force bool, buildOut io.Writer) error {
// 				panic("mock out the BuildImage method")
// 			},
// 			NamespaceFunc: func(ctx context.Context, namespace string) (confort.Namespace, error) {
// 				panic("mock out the Namespace method")
// 			},
// 		}
//
// 		// use mockedBackend in code that requires confort.Backend
// 		// and then make assertions.
//
// 	}
type BackendMock struct {
	// BuildImageFunc mocks the BuildImage method.
	BuildImageFunc func(ctx context.Context, buildContext io.Reader, buildOptions types.ImageBuildOptions, force bool, buildOut io.Writer) error

	// NamespaceFunc mocks the Namespace method.
	NamespaceFunc func(ctx context.Context, namespace string) (confort.Namespace, error)

	// calls tracks calls to the methods.
	calls struct {
		// BuildImage holds details about calls to the BuildImage method.
		BuildImage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BuildContext is the buildContext argument value.
			BuildContext io.Reader
			// BuildOptions is the buildOptions argument value.
			BuildOptions types.ImageBuildOptions
			// Force is the force argument value.
			Force bool
			// BuildOut is the buildOut argument value.
			BuildOut io.Writer
		}
		// Namespace holds details about calls to the Namespace method.
		Namespace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Namespace is the namespace argument value.
			Namespace string
		}
	}
	lockBuildImage sync.RWMutex
	lockNamespace  sync.RWMutex
}

// BuildImage calls BuildImageFunc.
func (mock *BackendMock) BuildImage(ctx context.Context, buildContext io.Reader, buildOptions types.ImageBuildOptions, force bool, buildOut io.Writer) error {
	if mock.BuildImageFunc == nil {
		panic("BackendMock.BuildImageFunc: method is nil but Backend.BuildImage was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		BuildContext io.Reader
		BuildOptions types.ImageBuildOptions
		Force        bool
		BuildOut     io.Writer
	}{
		Ctx:          ctx,
		BuildContext: buildContext,
		BuildOptions: buildOptions,
		Force:        force,
		BuildOut:     buildOut,
	}
	mock.lockBuildImage.Lock()
	mock.calls.BuildImage = append(mock.calls.BuildImage, callInfo)
	mock.lockBuildImage.Unlock()
	return mock.BuildImageFunc(ctx, buildContext, buildOptions, force, buildOut)
}

// BuildImageCalls gets all the calls that were made to BuildImage.
// Check the length with:
//     len(mockedBackend.BuildImageCalls())
func (mock *BackendMock) BuildImageCalls() []struct {
	Ctx          context.Context
	BuildContext io.Reader
	BuildOptions types.ImageBuildOptions
	Force        bool
	BuildOut     io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		BuildContext io.Reader
		BuildOptions types.ImageBuildOptions
		Force        bool
		BuildOut     io.Writer
	}
	mock.lockBuildImage.RLock()
	calls = mock.calls.BuildImage
	mock.lockBuildImage.RUnlock()
	return calls
}

// Namespace calls NamespaceFunc.
func (mock *BackendMock) Namespace(ctx context.Context, namespace string) (confort.Namespace, error) {
	if mock.NamespaceFunc == nil {
		panic("BackendMock.NamespaceFunc: method is nil but Backend.Namespace was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Namespace string
	}{
		Ctx:       ctx,
		Namespace: namespace,
	}
	mock.lockNamespace.Lock()
	mock.calls.Namespace = append(mock.calls.Namespace, callInfo)
	mock.lockNamespace.Unlock()
	return mock.NamespaceFunc(ctx, namespace)
}

// NamespaceCalls gets all the calls that were made to Namespace.
// Check the length with:
//     len(mockedBackend.NamespaceCalls())
func (mock *BackendMock) NamespaceCalls() []struct {
	Ctx       context.Context
	Namespace string
} {
	var calls []struct {
		Ctx       context.Context
		Namespace string
	}
	mock.lockNamespace.RLock()
	calls = mock.calls.Namespace
	mock.lockNamespace.RUnlock()
	return calls
}

// Ensure, that NamespaceMock does implement confort.Namespace.
// If this is not the case, regenerate this file with moq.
var _ confort.Namespace = &NamespaceMock{}

// NamespaceMock is a mock implementation of confort.Namespace.
//
// 	func TestSomethingThatUsesNamespace(t *testing.T) {
//
// 		// make and configure a mocked confort.Namespace
// 		mockedNamespace := &NamespaceMock{
// 			CreateContainerFunc: func(ctx context.Context, name string, containerMoqParam *container.Config, host *container.HostConfig, networkMoqParam *network.NetworkingConfig, configConsistency bool, pullOptions *types.ImagePullOptions, pullOut io.Writer) (string, error) {
// 				panic("mock out the CreateContainer method")
// 			},
// 			NamespaceFunc: func() string {
// 				panic("mock out the Namespace method")
// 			},
// 			NetworkFunc: func() *types.NetworkResource {
// 				panic("mock out the Network method")
// 			},
// 			ReleaseFunc: func(ctx context.Context) error {
// 				panic("mock out the Release method")
// 			},
// 			ReleaseContainerFunc: func(ctx context.Context, name string, exclusive bool) error {
// 				panic("mock out the ReleaseContainer method")
// 			},
// 			StartContainerFunc: func(ctx context.Context, name string, exclusive bool) (nat.PortMap, error) {
// 				panic("mock out the StartContainer method")
// 			},
// 		}
//
// 		// use mockedNamespace in code that requires confort.Namespace
// 		// and then make assertions.
//
// 	}
type NamespaceMock struct {
	// CreateContainerFunc mocks the CreateContainer method.
	CreateContainerFunc func(ctx context.Context, name string, containerMoqParam *container.Config, host *container.HostConfig, networkMoqParam *network.NetworkingConfig, configConsistency bool, pullOptions *types.ImagePullOptions, pullOut io.Writer) (string, error)

	// NamespaceFunc mocks the Namespace method.
	NamespaceFunc func() string

	// NetworkFunc mocks the Network method.
	NetworkFunc func() *types.NetworkResource

	// ReleaseFunc mocks the Release method.
	ReleaseFunc func(ctx context.Context) error

	// ReleaseContainerFunc mocks the ReleaseContainer method.
	ReleaseContainerFunc func(ctx context.Context, name string, exclusive bool) error

	// StartContainerFunc mocks the StartContainer method.
	StartContainerFunc func(ctx context.Context, name string, exclusive bool) (nat.PortMap, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateContainer holds details about calls to the CreateContainer method.
		CreateContainer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// ContainerMoqParam is the containerMoqParam argument value.
			ContainerMoqParam *container.Config
			// Host is the host argument value.
			Host *container.HostConfig
			// NetworkMoqParam is the networkMoqParam argument value.
			NetworkMoqParam *network.NetworkingConfig
			// ConfigConsistency is the configConsistency argument value.
			ConfigConsistency bool
			// PullOptions is the pullOptions argument value.
			PullOptions *types.ImagePullOptions
			// PullOut is the pullOut argument value.
			PullOut io.Writer
		}
		// Namespace holds details about calls to the Namespace method.
		Namespace []struct {
		}
		// Network holds details about calls to the Network method.
		Network []struct {
		}
		// Release holds details about calls to the Release method.
		Release []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReleaseContainer holds details about calls to the ReleaseContainer method.
		ReleaseContainer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Exclusive is the exclusive argument value.
			Exclusive bool
		}
		// StartContainer holds details about calls to the StartContainer method.
		StartContainer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Exclusive is the exclusive argument value.
			Exclusive bool
		}
	}
	lockCreateContainer  sync.RWMutex
	lockNamespace        sync.RWMutex
	lockNetwork          sync.RWMutex
	lockRelease          sync.RWMutex
	lockReleaseContainer sync.RWMutex
	lockStartContainer   sync.RWMutex
}

// CreateContainer calls CreateContainerFunc.
func (mock *NamespaceMock) CreateContainer(ctx context.Context, name string, containerMoqParam *container.Config, host *container.HostConfig, networkMoqParam *network.NetworkingConfig, configConsistency bool, pullOptions *types.ImagePullOptions, pullOut io.Writer) (string, error) {
	if mock.CreateContainerFunc == nil {
		panic("NamespaceMock.CreateContainerFunc: method is nil but Namespace.CreateContainer was just called")
	}
	callInfo := struct {
		Ctx               context.Context
		Name              string
		ContainerMoqParam *container.Config
		Host              *container.HostConfig
		NetworkMoqParam   *network.NetworkingConfig
		ConfigConsistency bool
		PullOptions       *types.ImagePullOptions
		PullOut           io.Writer
	}{
		Ctx:               ctx,
		Name:              name,
		ContainerMoqParam: containerMoqParam,
		Host:              host,
		NetworkMoqParam:   networkMoqParam,
		ConfigConsistency: configConsistency,
		PullOptions:       pullOptions,
		PullOut:           pullOut,
	}
	mock.lockCreateContainer.Lock()
	mock.calls.CreateContainer = append(mock.calls.CreateContainer, callInfo)
	mock.lockCreateContainer.Unlock()
	return mock.CreateContainerFunc(ctx, name, containerMoqParam, host, networkMoqParam, configConsistency, pullOptions, pullOut)
}

// CreateContainerCalls gets all the calls that were made to CreateContainer.
// Check the length with:
//     len(mockedNamespace.CreateContainerCalls())
func (mock *NamespaceMock) CreateContainerCalls() []struct {
	Ctx               context.Context
	Name              string
	ContainerMoqParam *container.Config
	Host              *container.HostConfig
	NetworkMoqParam   *network.NetworkingConfig
	ConfigConsistency bool
	PullOptions       *types.ImagePullOptions
	PullOut           io.Writer
} {
	var calls []struct {
		Ctx               context.Context
		Name              string
		ContainerMoqParam *container.Config
		Host              *container.HostConfig
		NetworkMoqParam   *network.NetworkingConfig
		ConfigConsistency bool
		PullOptions       *types.ImagePullOptions
		PullOut           io.Writer
	}
	mock.lockCreateContainer.RLock()
	calls = mock.calls.CreateContainer
	mock.lockCreateContainer.RUnlock()
	return calls
}

// Namespace calls NamespaceFunc.
func (mock *NamespaceMock) Namespace() string {
	if mock.NamespaceFunc == nil {
		panic("NamespaceMock.NamespaceFunc: method is nil but Namespace.Namespace was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNamespace.Lock()
	mock.calls.Namespace = append(mock.calls.Namespace, callInfo)
	mock.lockNamespace.Unlock()
	return mock.NamespaceFunc()
}

// NamespaceCalls gets all the calls that were made to Namespace.
// Check the length with:
//     len(mockedNamespace.NamespaceCalls())
func (mock *NamespaceMock) NamespaceCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNamespace.RLock()
	calls = mock.calls.Namespace
	mock.lockNamespace.RUnlock()
	return calls
}

// Network calls NetworkFunc.
func (mock *NamespaceMock) Network() *types.NetworkResource {
	if mock.NetworkFunc == nil {
		panic("NamespaceMock.NetworkFunc: method is nil but Namespace.Network was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNetwork.Lock()
	mock.calls.Network = append(mock.calls.Network, callInfo)
	mock.lockNetwork.Unlock()
	return mock.NetworkFunc()
}

// NetworkCalls gets all the calls that were made to Network.
// Check the length with:
//     len(mockedNamespace.NetworkCalls())
func (mock *NamespaceMock) NetworkCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNetwork.RLock()
	calls = mock.calls.Network
	mock.lockNetwork.RUnlock()
	return calls
}

// Release calls ReleaseFunc.
func (mock *NamespaceMock) Release(ctx context.Context) error {
	if mock.ReleaseFunc == nil {
		panic("NamespaceMock.ReleaseFunc: method is nil but Namespace.Release was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRelease.Lock()
	mock.calls.Release = append(mock.calls.Release, callInfo)
	mock.lockRelease.Unlock()
	return mock.ReleaseFunc(ctx)
}

// ReleaseCalls gets all the calls that were made to Release.
// Check the length with:
//     len(mockedNamespace.ReleaseCalls())
func (mock *NamespaceMock) ReleaseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRelease.RLock()
	calls = mock.calls.Release
	mock.lockRelease.RUnlock()
	return calls
}

// ReleaseContainer calls ReleaseContainerFunc.
func (mock *NamespaceMock) ReleaseContainer(ctx context.Context, name string, exclusive bool) error {
	if mock.ReleaseContainerFunc == nil {
		panic("NamespaceMock.ReleaseContainerFunc: method is nil but Namespace.ReleaseContainer was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Exclusive bool
	}{
		Ctx:       ctx,
		Name:      name,
		Exclusive: exclusive,
	}
	mock.lockReleaseContainer.Lock()
	mock.calls.ReleaseContainer = append(mock.calls.ReleaseContainer, callInfo)
	mock.lockReleaseContainer.Unlock()
	return mock.ReleaseContainerFunc(ctx, name, exclusive)
}

// ReleaseContainerCalls gets all the calls that were made to ReleaseContainer.
// Check the length with:
//     len(mockedNamespace.ReleaseContainerCalls())
func (mock *NamespaceMock) ReleaseContainerCalls() []struct {
	Ctx       context.Context
	Name      string
	Exclusive bool
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Exclusive bool
	}
	mock.lockReleaseContainer.RLock()
	calls = mock.calls.ReleaseContainer
	mock.lockReleaseContainer.RUnlock()
	return calls
}

// StartContainer calls StartContainerFunc.
func (mock *NamespaceMock) StartContainer(ctx context.Context, name string, exclusive bool) (nat.PortMap, error) {
	if mock.StartContainerFunc == nil {
		panic("NamespaceMock.StartContainerFunc: method is nil but Namespace.StartContainer was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Name      string
		Exclusive bool
	}{
		Ctx:       ctx,
		Name:      name,
		Exclusive: exclusive,
	}
	mock.lockStartContainer.Lock()
	mock.calls.StartContainer = append(mock.calls.StartContainer, callInfo)
	mock.lockStartContainer.Unlock()
	return mock.StartContainerFunc(ctx, name, exclusive)
}

// StartContainerCalls gets all the calls that were made to StartContainer.
// Check the length with:
//     len(mockedNamespace.StartContainerCalls())
func (mock *NamespaceMock) StartContainerCalls() []struct {
	Ctx       context.Context
	Name      string
	Exclusive bool
} {
	var calls []struct {
		Ctx       context.Context
		Name      string
		Exclusive bool
	}
	mock.lockStartContainer.RLock()
	calls = mock.calls.StartContainer
	mock.lockStartContainer.RUnlock()
	return calls
}
